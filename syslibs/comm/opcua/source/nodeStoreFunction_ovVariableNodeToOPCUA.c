/******************************************************************************
 *
 *   FILE
 *   ----
 *   nodeStoreFunctions.c
 *
 *   History
 *   -------
 *   2014-10-21   File created
 *
 *******************************************************************************
 *
 *   This file is generated by the 'acplt_builder' command
 *
 ******************************************************************************/

#ifndef OV_COMPILE_LIBRARY_opcua
#define OV_COMPILE_LIBRARY_opcua
#endif

#include "libov/ov_macros.h"
#include "ksbase.h"
#include "opcua.h"
#include "opcua_helpers.h"
#include "NoneTicketAuthenticator.h"
#include "libov/ov_path.h"
#include "libov/ov_memstack.h"
#include "ks_logfile.h"

extern OV_INSTPTR_opcua_uaServer opcua_pUaServer;


OV_DLLFNCEXPORT UA_StatusCode opcua_nodeStoreFunctions_ovVariableNodeToOPCUA(
		void *handle, OV_INSTPTR_opcua_variableNode ovNode, UA_VariableNode** opcuaNode) {
	OV_INSTPTR_ov_object pchild = NULL;
	*opcuaNode = NULL;
	*opcuaNode = ov_database_malloc(sizeof(UA_VariableNode));
	if (*opcuaNode == NULL)
		return 99;

	copyOvQualifiedNameToOPCUA	(&ovNode->p_browseName	, &(*opcuaNode)->browseName);
	copyOvLocalizedTextToOPCUA	(&ovNode->p_description	, &(*opcuaNode)->description);
	copyOvLocalizedTextToOPCUA	(&ovNode->p_displayName	, &(*opcuaNode)->displayName);
	copyOvNodeIdToOPCUA			(&ovNode->p_nodeId		, &(*opcuaNode)->nodeId);

	(*opcuaNode)->nodeClass 		= ovNode->v_nodeClass;
	//(*opcuaNode)->userWriteMask 	= ovNode->v_userWriteMask;
	(*opcuaNode)->writeMask 		= ovNode->v_writeMask;

	//count references and copy them to ua node structure
	size_t size_references = 0;
	Ov_ForEachChild(ov_containment,&ovNode->p_references,pchild) {
		size_references++;
	}
	(*opcuaNode)->references = UA_calloc(size_references, sizeof(UA_ReferenceNode));
	(*opcuaNode)->referencesSize = size_references;
	size_t i = 0;
	Ov_ForEachChild(ov_containment,&ovNode->p_references,pchild) {
		OV_INSTPTR_opcua_reference pref =
				Ov_DynamicPtrCast(opcua_reference,pchild);
		copyOvReferenceNodeToOPCUA(pref, &(*opcuaNode)->references[i]);
		i++;
	}

	//variable related fields
	(*opcuaNode)->valueRank 			= ovNode->v_valuerank;
	(*opcuaNode)->arrayDimensionsSize 	= ovNode->v_arrayDimensionsSize;
	(*opcuaNode)->arrayDimensions 		= UA_Array_new(ovNode->v_arrayDimensionsSize,
														&UA_TYPES[UA_TYPES_UINT32]);
	for (size_t i = 0; i < ovNode->v_arrayDimensionsSize; i++){
		(*opcuaNode)->arrayDimensions[i] = ovNode->v_arrayDimensions.value[i];
	}

	(*opcuaNode)->valueSource 				= ovNode->v_valueSource;
	(*opcuaNode)->accessLevel 				= ovNode->v_accessLevel;
	//(*opcuaNode)->userAccessLevel 			= ovNode->v_userAccessLevel;
	(*opcuaNode)->minimumSamplingInterval	= ovNode->v_minimumSamplingInterval;
	(*opcuaNode)->historizing 				= ovNode->v_historizing;
	copyOvNodeIdToOPCUA	(&ovNode->p_dataType, &(*opcuaNode)->dataType);

	if((*opcuaNode)->arrayDimensionsSize == 0){
		switch(ovNode->v_value.value.vartype & OV_VT_KSMASK){
		case OV_VT_BOOL:
			(*opcuaNode)->value.data.value.value.type = &UA_TYPES[UA_TYPES_BOOLEAN];
			(*opcuaNode)->value.data.value.value.data = UA_Boolean_new();
			*(UA_Boolean*)((*opcuaNode)->value.data.value.value.data) = ovNode->v_value.value.valueunion.val_bool;
			break;
		case OV_VT_BYTE:
			(*opcuaNode)->value.data.value.value.type = &UA_TYPES[UA_TYPES_BYTE];
			(*opcuaNode)->value.data.value.value.data = UA_Byte_new();
			*(UA_Byte*)((*opcuaNode)->value.data.value.value.data) = ovNode->v_value.value.valueunion.val_byte;
			break;
		case OV_VT_INT:
			(*opcuaNode)->value.data.value.value.type = &UA_TYPES[UA_TYPES_INT32];
			(*opcuaNode)->value.data.value.value.data = UA_Int32_new();
			*(UA_Int32*)((*opcuaNode)->value.data.value.value.data) = ovNode->v_value.value.valueunion.val_int;
			break;
		case OV_VT_UINT:
			(*opcuaNode)->value.data.value.value.type = &UA_TYPES[UA_TYPES_UINT32];
			(*opcuaNode)->value.data.value.value.data = UA_UInt32_new();
			*(UA_UInt32*)((*opcuaNode)->value.data.value.value.data) = ovNode->v_value.value.valueunion.val_uint;
			break;
		case OV_VT_SINGLE:
			(*opcuaNode)->value.data.value.value.type = &UA_TYPES[UA_TYPES_FLOAT];
			(*opcuaNode)->value.data.value.value.data = UA_Float_new();
			*(UA_Float*)((*opcuaNode)->value.data.value.value.data) = ovNode->v_value.value.valueunion.val_single;
			break;
		case OV_VT_DOUBLE:
			(*opcuaNode)->value.data.value.value.type = &UA_TYPES[UA_TYPES_DOUBLE];
			(*opcuaNode)->value.data.value.value.data = UA_Double_new();
			*(UA_Double*)((*opcuaNode)->value.data.value.value.data) = ovNode->v_value.value.valueunion.val_double;
			break;
		case OV_VT_STRING:
			(*opcuaNode)->value.data.value.value.type = &UA_TYPES[UA_TYPES_STRING];
			(*opcuaNode)->value.data.value.value.data = UA_String_new();
			copyOvStringToOPCUA(ovNode->v_value.value.valueunion.val_string,
							(UA_String*)((*opcuaNode)->value.data.value.value.data));
			break;
		default:
			break;
		}
	}else if((*opcuaNode)->arrayDimensionsSize == 1){
		switch(ovNode->v_value.value.vartype & OV_VT_KSMASK){
		case OV_VT_BOOL_VEC:
			(*opcuaNode)->value.data.value.value.type = &UA_TYPES[UA_TYPES_BOOLEAN];
			(*opcuaNode)->value.data.value.value.data = UA_Array_new(ovNode->v_arrayDimensions.value[0],
					&UA_TYPES[UA_TYPES_BOOLEAN]);
			for (size_t i = 0; i < (*opcuaNode)->arrayDimensions[0]; i++){
				*((UA_Boolean*)((*opcuaNode)->value.data.value.value.data)+i) = ovNode->v_value.value.valueunion.val_bool_vec.value[i];
			}
			break;
		case OV_VT_BYTE_VEC:
			(*opcuaNode)->value.data.value.value.type = &UA_TYPES[UA_TYPES_BYTE];
			(*opcuaNode)->value.data.value.value.data = UA_Array_new(ovNode->v_arrayDimensions.value[0],
					&UA_TYPES[UA_TYPES_BYTE]);
			for (size_t i = 0; i < (*opcuaNode)->arrayDimensions[0]; i++){
				*((UA_Byte*)((*opcuaNode)->value.data.value.value.data)+i) = ovNode->v_value.value.valueunion.val_byte_vec.value[i];
			}
			break;
		case OV_VT_INT_VEC:
			(*opcuaNode)->value.data.value.value.type = &UA_TYPES[UA_TYPES_INT32];
			(*opcuaNode)->value.data.value.value.data = UA_Array_new(ovNode->v_arrayDimensions.value[0],
					&UA_TYPES[UA_TYPES_INT32]);
			for (size_t i = 0; i < (*opcuaNode)->arrayDimensions[0]; i++){
				*((UA_Int32*)((*opcuaNode)->value.data.value.value.data)+i) = ovNode->v_value.value.valueunion.val_int_vec.value[i];
			}
			break;
		case OV_VT_UINT_VEC:
			(*opcuaNode)->value.data.value.value.type = &UA_TYPES[UA_TYPES_UINT32];
			(*opcuaNode)->value.data.value.value.data = UA_Array_new(ovNode->v_arrayDimensions.value[0],
					&UA_TYPES[UA_TYPES_UINT32]);
			for (size_t i = 0; i < (*opcuaNode)->arrayDimensions[0]; i++){
				*((UA_UInt32*)((*opcuaNode)->value.data.value.value.data)+i) = ovNode->v_value.value.valueunion.val_uint_vec.value[i];
			}
			break;
		case OV_VT_SINGLE_VEC:
			(*opcuaNode)->value.data.value.value.type = &UA_TYPES[UA_TYPES_FLOAT];
			(*opcuaNode)->value.data.value.value.data = UA_Array_new(ovNode->v_arrayDimensions.value[0],
					&UA_TYPES[UA_TYPES_FLOAT]);
			for (size_t i = 0; i < (*opcuaNode)->arrayDimensions[0]; i++){
				*((UA_Float*)((*opcuaNode)->value.data.value.value.data)+i) = ovNode->v_value.value.valueunion.val_single_vec.value[i];
			}
			break;
		case OV_VT_DOUBLE_VEC:
			(*opcuaNode)->value.data.value.value.type = &UA_TYPES[UA_TYPES_DOUBLE];
			(*opcuaNode)->value.data.value.value.data = UA_Array_new(ovNode->v_arrayDimensions.value[0],
					&UA_TYPES[UA_TYPES_DOUBLE]);
			for (size_t i = 0; i < (*opcuaNode)->arrayDimensions[0]; i++){
				*((UA_Double*)((*opcuaNode)->value.data.value.value.data)+i) = ovNode->v_value.value.valueunion.val_double_vec.value[i];
			}
			break;
		case OV_VT_STRING_VEC:
			(*opcuaNode)->value.data.value.value.type = &UA_TYPES[UA_TYPES_STRING];
			(*opcuaNode)->value.data.value.value.data = UA_Array_new(ovNode->v_arrayDimensions.value[0],
					&UA_TYPES[UA_TYPES_STRING]);
			for (size_t i = 0; i < (*opcuaNode)->arrayDimensions[0]; i++){
				copyOvStringToOPCUA(ovNode->v_value.value.valueunion.val_string_vec.value[i],
											(UA_String*)((*opcuaNode)->value.data.value.value.data)+i);
			}
			break;
		default:
			break;
		}
	}else{

	}


	return UA_STATUSCODE_GOOD;
}


